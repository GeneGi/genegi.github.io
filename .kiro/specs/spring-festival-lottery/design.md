# 设计文档

## 概述

春晚庙会抽奖网站是一个基于 Web 的单页应用程序（SPA），用于在春节庙会活动现场进行抽奖。系统采用前端架构，使用浏览器本地存储来持久化数据，无需后端服务器。

### 设计目标

- **简单易用**：管理员可以快速配置和执行抽奖
- **视觉吸引力**：采用春节主题设计，适合现场展示和拍照分享
- **可靠性**：通过本地存储确保数据不丢失
- **实时反馈**：提供流畅的动画和即时的操作反馈

## 架构

系统采用分层架构，分为以下几层：

```
┌─────────────────────────────────────┐
│      展示层 (Presentation)          │
│  - 配置界面                         │
│  - 抽奖界面                         │
│  - 结果展示界面                     │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│      业务逻辑层 (Business Logic)    │
│  - 奖品管理                         │
│  - 抽奖引擎                         │
│  - 状态管理                         │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│      数据层 (Data)                  │
│  - 本地存储接口                     │
│  - 数据序列化/反序列化              │
└─────────────────────────────────────┘
```

### 技术栈

- **前端框架**：React
- **样式**：CSS3 动画 + 春节主题样式
- **数据存储**：localStorage API
- **构建工具**：Vite

### 数据存储方案说明

系统使用浏览器的 **localStorage** 来存储数据，原因如下：

1. **单机使用场景**：活动现场只需要一台电脑操作抽奖，不需要多设备同步
2. **无需后端**：localStorage 是浏览器内置功能，无需搭建服务器或数据库
3. **简单可靠**：数据直接保存在本地，即使断网也能正常使用
4. **即时保存**：每次操作后立即保存，防止意外关闭浏览器导致数据丢失
5. **易于部署**：只需要一个静态网页文件，可以直接在浏览器中打开使用

**使用方式**：
- 配置奖品后，数据自动保存到浏览器本地
- 刷新页面后，之前的配置和抽奖状态会自动恢复
- 如果需要在另一台电脑上使用，可以重新配置奖品（或者导出/导入配置，作为可选功能）

## 组件和接口

### 3.1 数据模型组件

#### Prize（奖品）

```typescript
interface Prize {
  id: string;           // 唯一标识符（使用 UUID）
  name: string;         // 奖项名称（如"一等奖"）
  totalCount: number;   // 初始总数量
  remainingCount: number; // 剩余数量
  description?: string; // 奖品描述（可选）
}
```

#### LotteryState（抽奖状态）

```typescript
interface LotteryState {
  prizes: Prize[];           // 奖品列表
  currentResult?: Prize;     // 当前抽奖结果
  isDrawing: boolean;        // 是否正在抽奖
  totalDrawn: number;        // 已抽取总数
}
```

### 3.2 业务逻辑组件

#### PrizeManager（奖品管理器）

负责奖品的增删改查操作。

```typescript
class PrizeManager {
  // 添加新奖品
  addPrize(name: string, count: number): Prize
  
  // 更新奖品数量
  updatePrizeCount(prizeId: string, newCount: number): void
  
  // 删除奖品
  removePrize(prizeId: string): void
  
  // 获取所有奖品
  getAllPrizes(): Prize[]
  
  // 获取可抽取的奖品（剩余数量 > 0）
  getAvailablePrizes(): Prize[]
}
```

#### LotteryEngine（抽奖引擎）

负责执行抽奖逻辑。

```typescript
class LotteryEngine {
  // 执行抽奖
  draw(): Prize | null
  
  // 检查是否还有可抽取的奖品
  hasAvailablePrizes(): boolean
  
  // 减少奖品数量
  decrementPrize(prizeId: string): void
  
  // 重置所有奖品到初始状态
  reset(): void
}
```

**抽奖算法**：
1. 获取所有剩余数量 > 0 的奖品
2. 根据每个奖品的剩余数量计算权重
3. 使用加权随机算法选择一个奖品
4. 将选中奖品的剩余数量减 1
5. 返回选中的奖品

### 3.3 数据持久化组件

#### StorageService（存储服务）

负责与浏览器本地存储交互。

```typescript
class StorageService {
  private readonly STORAGE_KEY = 'lottery_state';
  
  // 保存状态到本地存储
  saveState(state: LotteryState): void
  
  // 从本地存储加载状态
  loadState(): LotteryState | null
  
  // 清除本地存储
  clearState(): void
}
```

**序列化格式**：使用 JSON 格式存储数据

### 3.4 展示层组件

#### ConfigurationView（配置视图）

- 显示奖品配置表单
- 允许添加/编辑/删除奖品
- 显示当前所有奖品及其剩余数量

#### LotteryView（抽奖视图）

- 显示"开始抽奖"按钮
- 执行抽奖动画
- 显示当前奖品池状态

#### ResultView（结果视图）

- 以大字体显示中奖奖项
- 显示春节主题装饰元素
- 提供视觉吸引力的展示效果

## 数据模型

### 状态流转

```
初始状态
   ↓
配置奖品 → 保存到本地存储
   ↓
准备抽奖
   ↓
执行抽奖 → 更新剩余数量 → 保存到本地存储
   ↓
显示结果
   ↓
继续抽奖 / 重置系统
```

### 数据验证规则

1. **奖品名称**：非空字符串，长度 1-50 字符
2. **奖品数量**：正整数，范围 1-10000
3. **奖品 ID**：唯一的 UUID 或时间戳生成的字符串

### 本地存储数据结构

```json
{
  "prizes": [
    {
      "id": "prize-1",
      "name": "一等奖",
      "totalCount": 1,
      "remainingCount": 0,
      "description": "iPhone 15 Pro"
    },
    {
      "id": "prize-2",
      "name": "二等奖",
      "totalCount": 3,
      "remainingCount": 2,
      "description": "小米手环"
    }
  ],
  "currentResult": null,
  "isDrawing": false,
  "totalDrawn": 2
}
```


## 正确性属性

*属性是一个特征或行为，应该在系统的所有有效执行中保持为真——本质上是关于系统应该做什么的形式化陈述。属性是人类可读规范和机器可验证正确性保证之间的桥梁。*

### 属性 1：奖品数量验证

*对于任何*输入的奖品数量值，如果该值不是正整数（包括负数、零、小数、非数字字符串），则系统应该拒绝该输入并返回验证错误。

**验证需求：1.3**

### 属性 2：奖品数量更新一致性

*对于任何*奖品和新的有效数量值，当更新该奖品的数量时，系统中该奖品的 remainingCount 应该等于新设置的值。

**验证需求：1.4**

### 属性 3：抽奖结果来自可用奖品池

*对于任何*奖品池状态，当执行抽奖操作时，返回的奖品必须是剩余数量大于零的奖品之一，或者当所有奖品数量都为零时返回 null。

**验证需求：2.1, 2.3**

### 属性 4：抽奖减少奖品数量

*对于任何*奖品池状态，当成功抽取一个奖品后，该奖品的剩余数量应该比抽奖前减少 1。

**验证需求：2.2**

### 属性 5：状态序列化往返一致性

*对于任何*有效的抽奖状态对象，将其序列化保存到本地存储然后再加载回来，应该得到一个等价的状态对象（所有奖品的 id、name、totalCount、remainingCount 都相同）。

**验证需求：4.1, 4.3**

### 属性 6：抽奖后持久化一致性

*对于任何*奖品池状态，执行抽奖操作并保存到本地存储后，重新加载状态时，奖品的剩余数量应该反映抽奖后的更新值。

**验证需求：4.2**

### 属性 7：重置清空所有数据

*对于任何*非空的抽奖状态，执行重置操作后，系统状态应该变为空状态（奖品列表为空，totalDrawn 为 0），并且本地存储中的数据也应该被清除。

**验证需求：5.3, 5.4, 5.5**

## 错误处理

### 输入验证错误

- **无效的奖品数量**：当用户输入非正整数时，显示友好的错误提示
- **空奖品名称**：当用户未输入奖品名称时，阻止提交并提示
- **重复的奖品名称**：可选择警告用户或允许重复

### 运行时错误

- **本地存储不可用**：如果浏览器禁用了 localStorage，显示警告并使用内存存储
- **数据损坏**：如果从本地存储加载的数据格式不正确，清除数据并重新开始
- **抽奖池为空**：当没有可用奖品时，禁用抽奖按钮并显示提示

### 边界情况

- **所有奖品已抽完**：显示"奖品已全部抽完"的提示，禁用抽奖按钮
- **空本地存储**：首次加载时显示欢迎界面，引导用户配置奖品
- **单个奖品**：确保只有一个奖品时抽奖逻辑正常工作
- **大量奖品**：确保系统能处理数百个奖品配置

## 测试策略

### 双重测试方法

系统将采用**单元测试**和**基于属性的测试**相结合的方法，以确保全面的测试覆盖：

- **单元测试**：验证特定示例、边界情况和错误条件
- **基于属性的测试**：验证所有输入的通用属性

两者是互补的且都是必需的：单元测试捕获具体的错误，基于属性的测试验证一般正确性。

### 基于属性的测试配置

- **测试库**：根据选择的编程语言使用相应的库
  - JavaScript/TypeScript: fast-check
  - Python: Hypothesis
  - Java: jqwik
  - 其他语言：选择成熟的 PBT 库
  
- **测试配置**：
  - 每个属性测试至少运行 100 次迭代（由于随机化）
  - 每个测试必须引用其设计文档中的属性
  - 标签格式：**Feature: spring-festival-lottery, Property {编号}: {属性文本}**

### 单元测试与属性测试的平衡

- 单元测试对于特定示例和边界情况很有帮助
- 避免编写过多的单元测试 - 基于属性的测试处理大量输入覆盖
- 单元测试应该关注：
  - 演示正确行为的特定示例
  - 组件之间的集成点
  - 边界情况和错误条件
- 属性测试应该关注：
  - 适用于所有输入的通用属性
  - 通过随机化实现全面的输入覆盖

### 测试覆盖范围

#### 单元测试示例

1. **奖品配置**
   - 添加有效奖品
   - 更新奖品数量
   - 删除奖品
   - 输入验证（空名称、负数、零）

2. **抽奖逻辑**
   - 从多个奖品中抽取
   - 抽取最后一个奖品
   - 尝试从空池中抽取
   - 验证数量递减

3. **数据持久化**
   - 保存和加载状态
   - 处理空存储
   - 处理损坏的数据

4. **重置功能**
   - 重置非空状态
   - 验证存储被清除

#### 基于属性的测试

每个正确性属性（属性 1-7）都必须由一个单独的基于属性的测试实现：

1. **属性 1**：生成各种无效输入，验证都被拒绝
2. **属性 2**：生成随机奖品和数量，验证更新一致性
3. **属性 3**：生成随机奖品池，验证抽奖结果有效性
4. **属性 4**：生成随机奖品池，验证数量递减
5. **属性 5**：生成随机状态，验证序列化往返
6. **属性 6**：生成随机状态，执行抽奖，验证持久化
7. **属性 7**：生成随机非空状态，验证重置清空

### 测试数据生成

对于基于属性的测试，需要生成：

- **随机奖品**：随机名称、随机数量（1-100）
- **随机奖品池**：0-20 个奖品的列表
- **随机状态**：包含随机奖品池和随机 totalDrawn 值
- **边界值**：空列表、单个奖品、所有数量为零的奖品

### 集成测试

虽然主要关注单元和属性测试，但也应该包括一些端到端的集成测试：

1. **完整抽奖流程**：配置 → 抽奖 → 查看结果 → 重置
2. **持久化流程**：配置 → 保存 → 刷新页面 → 验证恢复
3. **边界流程**：抽完所有奖品 → 验证禁用状态

### 性能测试

- 验证系统能处理至少 100 个奖品配置
- 验证抽奖操作在 100ms 内完成
- 验证本地存储读写操作不阻塞 UI
